import { Scenario } from '@/lib/types';

export const consistentHashingScenarios: Scenario[] = [
  {
    id: 'basic-distribution',
    name: 'Basic Key Distribution',
    concept: 'consistent-hashing',
    description: 'See how keys are distributed across servers using consistent hashing',
    initialState: {
      serverCount: 3,
      virtualNodes: 3,
    },
    events: [
      {
        id: 0,
        timestamp: 0,
        type: 'add_keys',
        description: 'Add 15 keys to the ring',
        data: { count: 15, prefix: 'user' },
      },
      {
        id: 1,
        timestamp: 1000,
        type: 'show_distribution',
        description: 'Display load distribution',
        data: {},
      },
    ],
    learningObjectives: [
      'Understand how consistent hashing distributes keys',
      'See virtual nodes on the ring',
      'Observe load distribution across servers',
    ],
    expectedOutcome: 'Keys are distributed across 3 servers with reasonable balance',
  },
  {
    id: 'add-server',
    name: 'Adding a Server',
    concept: 'consistent-hashing',
    description: 'Minimal key redistribution when adding a new server',
    initialState: {
      serverCount: 3,
      virtualNodes: 3,
    },
    events: [
      {
        id: 0,
        timestamp: 0,
        type: 'add_keys',
        description: 'Add 20 keys',
        data: { count: 20, prefix: 'data' },
      },
      {
        id: 1,
        timestamp: 1000,
        type: 'show_distribution',
        description: 'Initial distribution',
        data: {},
      },
      {
        id: 2,
        timestamp: 2000,
        type: 'add_server',
        description: 'Add server-3',
        data: { serverId: 'server-3' },
      },
      {
        id: 3,
        timestamp: 3000,
        type: 'show_distribution',
        description: 'New distribution (minimal keys moved)',
        data: {},
      },
    ],
    learningObjectives: [
      'See how adding a server redistributes only nearby keys',
      'Understand why consistent hashing minimizes data movement',
      'Observe O(K/N) keys moving instead of O(K)',
    ],
    expectedOutcome: 'Only ~25% of keys move to the new server',
  },
  {
    id: 'remove-server',
    name: 'Removing a Server',
    concept: 'consistent-hashing',
    description: 'Graceful redistribution when a server fails or is removed',
    initialState: {
      serverCount: 4,
      virtualNodes: 3,
    },
    events: [
      {
        id: 0,
        timestamp: 0,
        type: 'add_keys',
        description: 'Add 24 keys',
        data: { count: 24, prefix: 'item' },
      },
      {
        id: 1,
        timestamp: 1000,
        type: 'show_distribution',
        description: 'Initial distribution across 4 servers',
        data: {},
      },
      {
        id: 2,
        timestamp: 2000,
        type: 'remove_server',
        description: 'Remove server-1 (simulating failure)',
        data: { serverId: 'server-1' },
      },
      {
        id: 3,
        timestamp: 3000,
        type: 'show_distribution',
        description: 'Keys redistributed to remaining servers',
        data: {},
      },
    ],
    learningObjectives: [
      'Understand server failure handling',
      'See how keys are redistributed to adjacent nodes',
      'Learn about graceful degradation',
    ],
    expectedOutcome: "Removed server's keys are distributed among remaining servers",
  },
  {
    id: 'virtual-nodes-impact',
    name: 'Virtual Nodes Impact',
    concept: 'consistent-hashing',
    description: 'How virtual nodes improve load balance',
    initialState: {
      serverCount: 3,
      virtualNodes: 1,
    },
    events: [
      {
        id: 0,
        timestamp: 0,
        type: 'add_keys',
        description: 'Add 30 keys with 1 virtual node per server',
        data: { count: 30, prefix: 'doc' },
      },
      {
        id: 1,
        timestamp: 1000,
        type: 'show_distribution',
        description: 'Imbalanced distribution (1 virtual node)',
        data: {},
      },
      {
        id: 2,
        timestamp: 2000,
        type: 'set_virtual_nodes',
        description: 'Increase to 5 virtual nodes per server',
        data: { count: 5 },
      },
      {
        id: 3,
        timestamp: 3000,
        type: 'show_distribution',
        description: 'More balanced distribution (5 virtual nodes)',
        data: {},
      },
      {
        id: 4,
        timestamp: 4000,
        type: 'set_virtual_nodes',
        description: 'Increase to 10 virtual nodes per server',
        data: { count: 10 },
      },
      {
        id: 5,
        timestamp: 5000,
        type: 'show_distribution',
        description: 'Very balanced distribution (10 virtual nodes)',
        data: {},
      },
    ],
    learningObjectives: [
      'Understand the role of virtual nodes',
      'See how more virtual nodes improve balance',
      'Learn the trade-off between balance and memory',
    ],
    expectedOutcome: 'More virtual nodes lead to better load distribution',
  },
  {
    id: 'hot-spot',
    name: 'Handling Hot Spots',
    concept: 'consistent-hashing',
    description: 'Demonstrating uneven key distribution and mitigation',
    initialState: {
      serverCount: 3,
      virtualNodes: 2,
    },
    events: [
      {
        id: 0,
        timestamp: 0,
        type: 'add_keys',
        description: 'Add keys with similar hashes (creates hot spot)',
        data: { count: 20, prefix: 'cache-key-A' },
      },
      {
        id: 1,
        timestamp: 1000,
        type: 'show_distribution',
        description: 'Hot spot on one server',
        data: {},
      },
      {
        id: 2,
        timestamp: 2000,
        type: 'set_virtual_nodes',
        description: 'Increase virtual nodes to distribute load',
        data: { count: 8 },
      },
      {
        id: 3,
        timestamp: 3000,
        type: 'show_distribution',
        description: 'Hot spot mitigated',
        data: {},
      },
    ],
    learningObjectives: [
      'Understand how hash collisions create hot spots',
      'See how virtual nodes help distribute hot keys',
      'Learn mitigation strategies',
    ],
    expectedOutcome: 'Virtual nodes help distribute load more evenly',
  },
  {
    id: 'scaling-up-down',
    name: 'Scaling Up and Down',
    concept: 'consistent-hashing',
    description: 'Dynamic cluster resizing with consistent hashing',
    initialState: {
      serverCount: 2,
      virtualNodes: 4,
    },
    events: [
      {
        id: 0,
        timestamp: 0,
        type: 'add_keys',
        description: 'Add 16 keys',
        data: { count: 16, prefix: 'obj' },
      },
      {
        id: 1,
        timestamp: 500,
        type: 'show_distribution',
        description: '2 servers',
        data: {},
      },
      {
        id: 2,
        timestamp: 1000,
        type: 'add_server',
        description: 'Scale up: Add server-2',
        data: { serverId: 'server-2' },
      },
      {
        id: 3,
        timestamp: 1500,
        type: 'show_distribution',
        description: '3 servers',
        data: {},
      },
      {
        id: 4,
        timestamp: 2000,
        type: 'add_server',
        description: 'Scale up: Add server-3',
        data: { serverId: 'server-3' },
      },
      {
        id: 5,
        timestamp: 2500,
        type: 'show_distribution',
        description: '4 servers',
        data: {},
      },
      {
        id: 6,
        timestamp: 3000,
        type: 'remove_server',
        description: 'Scale down: Remove server-0',
        data: { serverId: 'server-0' },
      },
      {
        id: 7,
        timestamp: 3500,
        type: 'show_distribution',
        description: 'Back to 3 servers',
        data: {},
      },
    ],
    learningObjectives: [
      'See dynamic scaling in action',
      'Understand incremental redistribution',
      'Learn about elastic infrastructure',
    ],
    expectedOutcome: 'Smooth scaling with minimal data movement at each step',
  },
];
