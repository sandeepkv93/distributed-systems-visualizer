import { Scenario } from '@/lib/types';

export const eventualConsistencyScenarios: Scenario[] = [
  {
    id: 'basic-replication',
    name: 'Basic Write and Replication',
    concept: 'eventual-consistency',
    description: 'Simple write operation with asynchronous replication',
    initialState: {
      nodeCount: 3,
      replicationFactor: 3,
    },
    events: [
      {
        id: 0,
        timestamp: 0,
        type: 'write',
        description: 'Write user:1={name: "Alice"} to N0 (QUORUM)',
        data: { key: 'user:1', value: { name: 'Alice' }, nodeId: 'N0', consistencyLevel: 'QUORUM' },
      },
      {
        id: 1,
        timestamp: 500,
        type: 'replicate_complete',
        description: 'Replication to N1 and N2 complete',
        data: {},
      },
      {
        id: 2,
        timestamp: 1000,
        type: 'read',
        description: 'Read user:1 from N2 (ONE)',
        data: { key: 'user:1', nodeId: 'N2', consistencyLevel: 'ONE' },
      },
      {
        id: 3,
        timestamp: 1500,
        type: 'show_consistency',
        description: 'All nodes now consistent',
        data: {},
      },
    ],
    learningObjectives: [
      'Understand asynchronous replication',
      'See how writes propagate across nodes',
      'Learn about consistency levels (ONE, QUORUM, ALL)',
    ],
    expectedOutcome: 'Data eventually consistent across all replicas',
  },
  {
    id: 'read-consistency-levels',
    name: 'Consistency Levels Comparison',
    concept: 'eventual-consistency',
    description: 'Compare ONE vs QUORUM vs ALL for reads',
    initialState: {
      nodeCount: 5,
      replicationFactor: 3,
    },
    events: [
      {
        id: 0,
        timestamp: 0,
        type: 'write',
        description: 'Write product:100={price: 50} to N0 (ONE)',
        data: { key: 'product:100', value: { price: 50 }, nodeId: 'N0', consistencyLevel: 'ONE' },
      },
      {
        id: 1,
        timestamp: 200,
        type: 'read',
        description: 'Read from N1 (ONE) - might be stale',
        data: { key: 'product:100', nodeId: 'N1', consistencyLevel: 'ONE' },
      },
      {
        id: 2,
        timestamp: 700,
        type: 'replicate_progress',
        description: 'Replication in progress...',
        data: {},
      },
      {
        id: 3,
        timestamp: 1000,
        type: 'read',
        description: 'Read from N2 (QUORUM) - checks majority',
        data: { key: 'product:100', nodeId: 'N2', consistencyLevel: 'QUORUM' },
      },
      {
        id: 4,
        timestamp: 1500,
        type: 'read',
        description: 'Read from N3 (ALL) - checks all replicas',
        data: { key: 'product:100', nodeId: 'N3', consistencyLevel: 'ALL' },
      },
    ],
    learningObjectives: [
      'Understand trade-offs between consistency levels',
      'Learn when to use ONE vs QUORUM vs ALL',
      'See impact on latency and consistency',
    ],
    expectedOutcome: 'Different consistency levels provide different guarantees',
  },
  {
    id: 'node-failure-recovery',
    name: 'Node Failure and Recovery',
    concept: 'eventual-consistency',
    description: 'Handle node failures gracefully',
    initialState: {
      nodeCount: 4,
      replicationFactor: 3,
    },
    events: [
      {
        id: 0,
        timestamp: 0,
        type: 'write',
        description: 'Write session:abc={userId: 42} to N0',
        data: { key: 'session:abc', value: { userId: 42 }, nodeId: 'N0', consistencyLevel: 'QUORUM' },
      },
      {
        id: 1,
        timestamp: 500,
        type: 'replicate_complete',
        description: 'Replicated to N1, N2',
        data: {},
      },
      {
        id: 2,
        timestamp: 1000,
        type: 'fail_node',
        description: 'N1 fails',
        data: { nodeId: 'N1' },
      },
      {
        id: 3,
        timestamp: 1500,
        type: 'write',
        description: 'Write session:xyz={userId: 99} to N2',
        data: { key: 'session:xyz', value: { userId: 99 }, nodeId: 'N2', consistencyLevel: 'QUORUM' },
      },
      {
        id: 4,
        timestamp: 2000,
        type: 'read',
        description: 'Read from N3 (QUORUM) - still works',
        data: { key: 'session:xyz', nodeId: 'N3', consistencyLevel: 'QUORUM' },
      },
      {
        id: 5,
        timestamp: 2500,
        type: 'recover_node',
        description: 'N1 recovers',
        data: { nodeId: 'N1' },
      },
      {
        id: 6,
        timestamp: 3000,
        type: 'anti_entropy',
        description: 'Anti-entropy sync to catch up N1',
        data: {},
      },
      {
        id: 7,
        timestamp: 3500,
        type: 'show_consistency',
        description: 'N1 caught up, all nodes consistent',
        data: {},
      },
    ],
    learningObjectives: [
      'Understand fault tolerance in eventual consistency',
      'See how recovered nodes catch up',
      'Learn about anti-entropy processes',
    ],
    expectedOutcome: 'System remains available during failures, data syncs after recovery',
  },
  {
    id: 'concurrent-writes',
    name: 'Concurrent Writes and Conflicts',
    concept: 'eventual-consistency',
    description: 'Handle concurrent writes to the same key',
    initialState: {
      nodeCount: 3,
      replicationFactor: 3,
    },
    events: [
      {
        id: 0,
        timestamp: 0,
        type: 'write',
        description: 'N0 writes counter:1=10',
        data: { key: 'counter:1', value: 10, nodeId: 'N0', consistencyLevel: 'ONE' },
      },
      {
        id: 1,
        timestamp: 100,
        type: 'write',
        description: 'N1 writes counter:1=20 (concurrent!)',
        data: { key: 'counter:1', value: 20, nodeId: 'N1', consistencyLevel: 'ONE' },
      },
      {
        id: 2,
        timestamp: 500,
        type: 'show_conflict',
        description: 'Conflict detected: N0 has 10, N1 has 20',
        data: {},
      },
      {
        id: 3,
        timestamp: 1000,
        type: 'anti_entropy',
        description: 'Anti-entropy resolves using vector clocks',
        data: {},
      },
      {
        id: 4,
        timestamp: 1500,
        type: 'show_resolution',
        description: 'Conflict resolved (last-write-wins)',
        data: {},
      },
    ],
    learningObjectives: [
      'Understand concurrent write conflicts',
      'See how vector clocks detect conflicts',
      'Learn conflict resolution strategies',
    ],
    expectedOutcome: 'Conflicts detected and resolved automatically',
  },
  {
    id: 'anti-entropy-sync',
    name: 'Anti-Entropy Synchronization',
    concept: 'eventual-consistency',
    description: 'Background gossip protocol keeps nodes in sync',
    initialState: {
      nodeCount: 5,
      replicationFactor: 2,
    },
    events: [
      {
        id: 0,
        timestamp: 0,
        type: 'write',
        description: 'Write data:a=1 to N0 (ONE)',
        data: { key: 'data:a', value: 1, nodeId: 'N0', consistencyLevel: 'ONE' },
      },
      {
        id: 1,
        timestamp: 200,
        type: 'write',
        description: 'Write data:b=2 to N2 (ONE)',
        data: { key: 'data:b', value: 2, nodeId: 'N2', consistencyLevel: 'ONE' },
      },
      {
        id: 2,
        timestamp: 400,
        type: 'write',
        description: 'Write data:c=3 to N4 (ONE)',
        data: { key: 'data:c', value: 3, nodeId: 'N4', consistencyLevel: 'ONE' },
      },
      {
        id: 3,
        timestamp: 700,
        type: 'show_inconsistency',
        description: 'Nodes have different data',
        data: {},
      },
      {
        id: 4,
        timestamp: 1000,
        type: 'anti_entropy',
        description: 'Round 1: Gossip sync',
        data: {},
      },
      {
        id: 5,
        timestamp: 1500,
        type: 'anti_entropy',
        description: 'Round 2: More gossip',
        data: {},
      },
      {
        id: 6,
        timestamp: 2000,
        type: 'anti_entropy',
        description: 'Round 3: Final sync',
        data: {},
      },
      {
        id: 7,
        timestamp: 2500,
        type: 'show_consistency',
        description: 'All nodes eventually consistent',
        data: {},
      },
    ],
    learningObjectives: [
      'Understand gossip-based anti-entropy',
      'See how data propagates through the system',
      'Learn about eventual convergence',
    ],
    expectedOutcome: 'Nodes converge to consistent state through gossip',
  },
  {
    id: 'availability-partition',
    name: 'Availability During Network Partition',
    concept: 'eventual-consistency',
    description: 'System remains available despite network partition',
    initialState: {
      nodeCount: 4,
      replicationFactor: 2,
    },
    events: [
      {
        id: 0,
        timestamp: 0,
        type: 'write',
        description: 'Write inventory:item1=100 to N0',
        data: { key: 'inventory:item1', value: 100, nodeId: 'N0', consistencyLevel: 'ONE' },
      },
      {
        id: 1,
        timestamp: 500,
        type: 'partition',
        description: 'Network partition: {N0,N1} | {N2,N3}',
        data: { partition: [['N0', 'N1'], ['N2', 'N3']] },
      },
      {
        id: 2,
        timestamp: 1000,
        type: 'write',
        description: 'Write to N0 in partition A (still works)',
        data: { key: 'inventory:item1', value: 95, nodeId: 'N0', consistencyLevel: 'ONE' },
      },
      {
        id: 3,
        timestamp: 1200,
        type: 'write',
        description: 'Write to N2 in partition B (also works!)',
        data: { key: 'inventory:item1', value: 90, nodeId: 'N2', consistencyLevel: 'ONE' },
      },
      {
        id: 4,
        timestamp: 1500,
        type: 'show_divergence',
        description: 'Partitions have diverged',
        data: {},
      },
      {
        id: 5,
        timestamp: 2000,
        type: 'heal_partition',
        description: 'Partition heals',
        data: {},
      },
      {
        id: 6,
        timestamp: 2500,
        type: 'anti_entropy',
        description: 'Merge data from both partitions',
        data: {},
      },
      {
        id: 7,
        timestamp: 3000,
        type: 'show_resolution',
        description: 'Conflict resolved, system consistent',
        data: {},
      },
    ],
    learningObjectives: [
      'Understand AP (Availability + Partition tolerance) from CAP',
      'See how system stays available during partition',
      'Learn about partition healing and merge',
    ],
    expectedOutcome: 'System prioritizes availability, reconciles after partition heals',
  },
];
